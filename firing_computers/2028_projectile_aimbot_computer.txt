--@name 2028 Projectile Aimbot Computer
--@author Ally for Hire / Merydian9
--@include ../public_lib/acf_ballistics_lib.txt
--@shared
--@server

--- Version 1.0.0
-- Total implementation

--- Version 1.0.1
-- Minor changes

--- Version 1.0.2
-- Fixed issue where gun fires without solution

--- Version 1.03
-- Added ACF3 compatability
-- Fixed firing issue where accidental rounding would cause gun not to fire

--- Version 1.0.4
-- Added 'Fire' output

--- Version 1.0.5
-- Fixed series of bugs with that lol
-- Reimplemented firing delay 
-- Removed accel check for bisection
-- Added dt as default offset
-- Various optimization changes
-- Removal of gun firing

ballisticslib = require("../public_lib/acf_ballistics_lib.txt")

--- User Variables
local offset = 0.00 -- Time offset in seconds, 0.02 is about 1 tick ish
local handleFiring = true -- Whether or not the starfall will fire the gun automatically
local firingRange = 4000 -- Range the projectile will be at when it gets intercepted if handleFiring is true
local firingAccuracy = 0.3 -- Distance between the target and where the gun is aiming in meters

--- Do not touch below this

--- Constants
local GRAVITY = Vector2(0, physenv.getGravity()[3])
local TICK = game.getTickInterval()

--- Wire Stand-in Variables 
local gun = nil
local targetPos = nil
local targetVel = nil
local targetAccel = nil
local lastVel = Vector()
local lastFrame = 0

--- Internal Variables
local initialized = false
local storedMuzzleVel = 0
local maxCalculatedRange = 0
local muzzleDist = 0
local relativeAccel = Vector(0)
local attemptingFire = false
local fireOutput = 0

--- Time to actually do the math and logic
local function main()
    -- Short list of early-outs this time
    if storedMuzzleVel == 0 then return end
    
    if handleFiring then fireOutput = 0 end
    
    -- Simple acceleration handling via calculating change in velocity over dt
    local relativeAccel = -Vector(0, 0, GRAVITY[2])
    local dt = game.getTickInterval()
    if lastVel != targetVel then
        dt = timer.curtime() - lastFrame
        
        relativeAccel = relativeAccel + (targetVel - lastVel) / dt
        
        lastVel = targetVel
        lastFrame = timer.curtime()
    end
    
    -- Preparing variables for use with our equations
    local relativePos = targetPos - gun:getPos()
    local relativeVel = targetVel - gun:getVelocity()
    local low = game.getTickInterval()
    local time = low
    local high = (relativePos):getLength() / (storedMuzzleVel * 39.37)

    -- Use equations of motion to solve the interception point between our two projectiles regardless of exact motion
    local predictedTargetPos = relativePos
    local targetValue = predictedTargetPos:getLength() - muzzleDist
    local selfValue = 0 -- this fucker is why any of this is so hard
    local data = {Vector2(0), 0}
    
    -- Simple binary search to find the solution to those equations
    while (high - low) > 0.001 and targetValue < firingRange and not attemptingFire and gun:acfReady() do
        time = (low + high) / 2
        
        -- Predict target position with acceleration applied
        predictedTargetPos = relativePos + relativeVel * time + 1/2 * relativeAccel * time^2
        targetValue = predictedTargetPos:getLength() - muzzleDist
        data = ballisticslib.logic(gun, predictedTargetPos, time)
        selfValue = data[1]:getLength()
        
        if targetValue > maxCalculatedRange then
            break  
        end
        
        -- Make sure we stop if we go past the target or if the target goes past us
        if targetValue > selfValue and predictedTargetPos:dot(relativePos) > 0 then
            low = time
        else
            high = time
        end           
    end
    
    -- Wire outputs
    local timeOutput = time + dt
    local aimposOutput = targetPos + relativeVel * (timeOutput + offset) + 0.5 * relativeAccel * (timeOutput + offset)^2
    wire.ports.Time = timeOutput
    wire.ports.AimPos = aimposOutput
    
    -- Gun fire handling
    if handleFiring and targetValue < firingRange and time != game.getTickInterval() and gun:acfReady() then
        -- Barrel alignment check
        local muzzle = gun:getAttachment(gun:lookupAttachment("muzzle"))
        local muzzleVec = Vector(muzzle[1], muzzle[2], muzzle[3])
        local gunFwd = gun:getForward()
        local toAim = aimposOutput - muzzleVec
        local proj = gunFwd * toAim:dot(gunFwd)
        local closest = muzzleVec + proj
        local error = (aimposOutput - closest):getLength()

        if error < firingAccuracy and not attemptingFire then
            fireOutput = 1
        end
    end
    
    wire.ports.Fire = fireOutput
end

--- Updates variables with their respective values when needed
-- Also attempts logic when possible
local function handleWire(name, value)
    if name == "Gun" then
        gun = value
    elseif name == "TargetPos" then
        targetPos = value    
    elseif name == "TargetVel" then
        targetVel = value    
    end
end

--- Need to retry in-case the ballistics change, just in case
-- Try to update the logic every 1s
timer.create("retry", 1, 0, function()
    if gun:isValid() and gun:acfMuzzleVel() == 0 then
        wire.ports.Fire = 1
    elseif gun:isValid() then
        if gun:acfMuzzleVel() != storedMuzzleVel then
            storedMuzzleVel = gun:acfMuzzleVel()
            maxCalculatedRange = ballisticslib.calculate_maximum_distance(gun)
            local attachmentInfo = gun:getAttachment(gun:lookupAttachment("muzzle"))
            local muzzlePos = Vector(attachmentInfo[1], attachmentInfo[2], attachmentInfo[3])
            muzzleDist = gun:localToWorld(Vector()):getDistance(muzzlePos)
            wire.ports.Fire = 0
        end
    end
end)

--- Hook for when the wire inputs are updated
-- This is basically the only hook we need since we only care when we are actually recieving data
wire.adjustPorts({Gun = "entity", TargetPos = "vector", TargetVel = "vector"},{Fire = "number", Time = "number", AimPos = "vector"})
hook.add("input", "Wire Inputs Updated", handleWire)

--- Main think hook, pretty self explanatory
hook.add("think", "Main Think", main)
