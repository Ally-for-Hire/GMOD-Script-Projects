--@name 2027 Projectile Aimbot Computer
--@author Ally for Hire / Merydian9
--@shared
--@server

-- I basically already made a starfall that does most of this, so i'm taking alot of it from there
-- This is assuming target on a level plane, but at close-range it honestly shouldn't matter excessively
-- Hypothetically should still be close on targets far away but that's tbd
-- Stick between the range of 150-800 m/s muzzle velocity, above and below that you will begin to see issues

--- Version 1.1
-- Comments added
-- Slight code cleanup
-- Option to fire added
-- Fixed an issue with data table logic
-- Fixed an issue with firing logic
-- Fixed an issue with acceleration logic
-- Fixed an issue with table generation logic

wire.adjustPorts({Gun = "entity", TargetPos = "vector", TargetVel = "vector"},{Time = "number", AimPos = "vector"})

-- Constants and Dev Stuff, no touchy
local MAX_TIME = 4
local TIME_STEP = game.getTickInterval()
local GRAVITY = Vector2(0, -600)
local RAD_CONV = 0.0174533
local VISUALIZE_BALLISTICS_TABLE = false 
local VISUALIZE_FINAL_TABLE = false

-- Wire Stand-in Variables 
local gun = nil
local targetPos = nil
local targetVel = nil
local targetAccel = nil
local lastVel = Vector()
local lastFrame = 0

-- Actual Variables
local initialized = false
local storedMuzzleVel = 0
local maxCalculatedRange = 0
local pitchStep = 0
local outputTime = 0
local dataTable = {}
local offset = 0 -- time offset in seconds, to adjust for gg5 being behind
local firingRange = 1000 -- range at which the gun fires, adjusted for target velocity, for kinetic rounds go far for chemical rounds go close
local handleFiring = true -- whether or not the starfall itsself will handle gun firing 

--- Generates the ballistics of the shell at the given pitch
-- Pretty simple function, just generates until the elevation is 0
local function generateAngleBallistics(gun, pitch, dt)
    -- Initialization of variables
    local curtime = 0
    local indices = 0
    local dragCoef = gun:acfDragCoef()
    
    -- Calculating the starting position of the shell
    local attachmentInfo = gun:getAttachment(gun:lookupAttachment("muzzle"))
    local muzzlePos = Vector(attachmentInfo[1], attachmentInfo[2], attachmentInfo[3])
    local muzzleDist = gun:getMassCenterW():getDistance(muzzlePos)
    
    -- Calculating the starting velocity of the shell
    local muzzleVel = gun:acfMuzzleVel() * 39.37
    
    local shellPos = Vector2(math.cos(pitch), math.sin(pitch)) * muzzleDist 
    local shellVel = Vector2(math.cos(pitch), math.sin(pitch)) * muzzleVel
    
    -- Generic bullet sim from ACE code
    while curtime < MAX_TIME and shellVel[1] > 0 do
        local drag = (dragCoef * shellVel:getLength()^2) / 40
        drag = shellVel:getNormalized() * (drag * dt)
        drag = Vector2(drag[1], drag[2]) * 39.37
        
        shellPos = shellPos + shellVel * dt
        shellVel = shellVel + (GRAVITY * dt) - drag
                
        curtime = curtime + dt
        indices = indices + 1
        
        --outputTable[indices] = {shellPos, shellVel, curtime, math.sqrt(shellPos[1]^2 + shellPos[2]^2)} -- 2D Position, 2D Velocity, Current Time, Distance from Start
        if VISUALIZE_BALLISTICS_TABLE and indices < 200 then 
            local holo = hologram.create(gun:localToWorld(Vector(shellPos[1], 0, shellPos[2])), Angle(), "models/sprops/cuboids/height06/size_1/cube_6x6x6.mdl")
            --holo:setParent(gun)
        end
        
        -- We can stop once we hit the threshold we are looking for
        if shellPos[2] < 0 then
            break
        end
    end
    
    return {shellPos[1], shellPos[2], curtime}
end

--- Attempts to generate values so we can get this show on the road
local function generateValues()
    -- Extensive list of early-outs
    if gun == nil or not gun:isValid() or gun:getClass() != "acf_gun" or gun:acfMuzzleVel() == storedMuzzleVel then return end
    
    gun:acfFire(0)
    
    -- Variable decleration and cleanup
    storedMuzzleVel = gun:acfMuzzleVel()
    pitchStep = 4 / storedMuzzleVel -- [NUM] / Muzzle Vel is the pitch step in degrees. Higher number means less steps so less accuracy, but also less lag. The vice versa is also true. 4 is the default
    hologram.removeAll()
    
    -- Make a table of every point at which the bullet intersects y=0 of the gun
    local pitch = 0
    local data = {0, 0, 0}
    dataTable[1] = {0, 0, 0}
    local indices = 2
    while data[3] < 3.9 and pitch < 40 do
        data = generateAngleBallistics(gun, pitch * RAD_CONV, TIME_STEP)
        dataTable[indices] = data
        
        if VISUALIZE_FINAL_TABLE and indices < 200 then
            local holo = hologram.create(gun:localToWorld(Vector(data[1] * math.cos(pitch * RAD_CONV), 0, data[1] * -math.sin(pitch * RAD_CONV))), Angle(), "models/sprops/cuboids/height06/size_1/cube_6x6x6.mdl")
            holo:setParent(gun)
        end
        
        pitch = pitch + pitchStep
        indices = indices + 1
    end
    
    -- Store the maximum data so we can early-out later
    maxCalculatedRange = dataTable[indices - 1][1]
    initialized = true
    
    print("Range .. " .. maxCalculatedRange)
end

--- Updates variables with their respective values when needed
-- Also attempts logic when possible
local function handleWire(name, value)
    if name == "Gun" then
        gun = value
        generateValues()
    elseif name == "TargetPos" then
        targetPos = value    
    elseif name == "TargetVel" then
        targetVel = value    
    end
end

--- Interpolates our friend the dataTable
local function interpolateTable(tbl, targetTime)
    for i = 1, #tbl - 1 do
        local t0, t1 = tbl[i][3], tbl[i + 1][3]
        if targetTime >= t0 and targetTime <= t1 then
            local d0, d1 = tbl[i][1], tbl[i + 1][1]
            local alpha = (targetTime - t0) / (t1 - t0)
            return d0 + (d1 - d0) * alpha
        end
    end
    
    return 0
end

--- Time to actually do the math and logic
local function main()
    -- Short list of early-outs this time
    if not initialized then return end
    if targetPos == nil or targetVel == nil or targetPos == Vector(0, 0, 0) then return end
    
    if handleFiring then gun:acfFire(0) end
    
    -- Calculate time delta to avoid division by zero in acceleration calculation
    local dt = timer.curtime() - lastFrame
    local acceleration = -Vector(0, 0, GRAVITY[2])
    if dt > 0 and lastVel != targetVel and lastVel != Vector() then
        acceleration = (targetVel - lastVel) / dt - Vector(0, 0, GRAVITY[2])
        lastVel = targetVel
        lastFrame = timer.curtime()
    end
    
    local relativePos = targetPos - gun:getPos()
    local relativeVel = targetVel - gun:getVelocity()
    local time = 0
    local low = 0
    local high = MAX_TIME

    -- Use kinematic equation for predicted target position
    local predictedTargetPos = relativePos + relativeVel * time + 0.5 * acceleration * time^2
    local targetValue = predictedTargetPos:getLength()
    local selfValue = interpolateTable(dataTable, time)
    
    while (high - low) > 0.0001 do
        time = (low + high) / 2
        
        -- Predict target position with acceleration applied
        predictedTargetPos = relativePos + relativeVel * time + 0.5 * acceleration * time^2
        targetValue = predictedTargetPos:getLength()
        selfValue = interpolateTable(dataTable, time)
        
        if targetValue > maxCalculatedRange then
            return 0    
        end
        
        if targetValue > selfValue and (predictedTargetPos:getLength() - relativePos:getLength()) < relativeVel:getLength() then 
            low = time
        else
            high = time
        end            
    end

    outputTime = time
    
    wire.ports.Time = outputTime + offset
    wire.ports.AimPos = targetPos + targetVel * outputTime + 0.5 * acceleration * outputTime^2
    
    if(targetValue < firingRange and time != 0 and targetPos != Vector(0) and handleFiring) then gun:acfFire(1) end
    
    timer.create("Reset Acceleration", 0.1, 1, function() lastVel = Vector(0) end)
end


--- Need to retry in-case the ballistics change, just in case
-- Try to update the logic every 1s
timer.create("retry", 0.1, 0, function(NAME, VALUE)
    generateValues()
    
    if gun:isValid() and gun:acfMuzzleVel() == 0 then
        gun:acfFire(1)
    elseif gun:isValid() then
        gun:acfFire(0)
    end
end)

--- Hook for when the wire inputs are updated
-- This is basically the only hook we need since we only care when we are actually recieving data
hook.add("input", "Wire Inputs Updated", handleWire)

--- Main think hook, pretty self explanatory
hook.add("think", "Main Think", main)
