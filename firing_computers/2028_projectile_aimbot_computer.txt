--@name 2028 Projectile Aimbot Computer
--@author Ally for Hire / Merydian9
--@include ../public_lib/acf_ballistics_lib.txt
--@shared
--@server

--- Version 1.0.0
-- Total implementation

--- Version 1.0.1
-- Minor changes

--- Version 1.0.2
-- Fixed issue where gun fires without solution

ballisticslib = require("../public_lib/acf_ballistics_lib.txt")

--- User Variables
local offset = 0.0 -- Time offset in seconds, 0.02 is about 1 tick ish
local handleFiring = true -- Whether or not the starfall will fire the gun automatically
local firingRange = 6500 -- Range the projectile will be at when it gets intercepted if handleFiring is true
local firingAccuracy = 0.3 -- Distance between the target and where the gun is aiming in meters

--- Do not touch below this

--- Constants
local GRAVITY = Vector2(0, physenv.getGravity()[3])
local TICK = game.getTickInterval()

--- Wire Stand-in Variables 
local gun = nil
local targetPos = nil
local targetVel = nil
local targetAccel = nil
local lastVel = Vector()
local lastFrame = 0

--- Internal Variables
local initialized = false
local storedMuzzleVel = 0
local maxCalculatedRange = 0
local muzzleDist = 0
local relativeAccel = Vector(0)
local attemptingFire = false

--- Time to actually do the math and logic
local function main()
    -- Short list of early-outs this time
    if targetPos == nil or targetVel == nil or targetPos == Vector(0, 0, 0) or storedMuzzleVel == 0 then return end
    
    if handleFiring then gun:acfFire(0) end
    
    -- Simple acceleration handling via calculating change in velocity over dt
    local relativeAccel = -Vector(0, 0, GRAVITY[2])
    if lastVel != targetVel then
        local dt = timer.curtime() - lastFrame
        
        relativeAccel = relativeAccel + (targetVel - lastVel) / dt
        
        lastVel = targetVel
        lastFrame = timer.curtime()
    end
    
    -- Preparing variables for use with our equations
    local relativePos = targetPos - gun:getPos()
    local relativeVel = targetVel - gun:getVelocity()
    local low = 0.01
    local time = low
    local high = (relativePos):getLength() / (storedMuzzleVel * 39.37)

    -- Use equations of motion to solve the interception point between our two projectiles regardless of exact motion
    local predictedTargetPos = relativePos
    local targetValue = predictedTargetPos:getLength() - muzzleDist
    local selfValue = 0 -- this fucker is why any of this is so hard
    local data = {Vector2(0), 0}
    
    -- Simple binary search to find the solution to those equations
    while (high - low) > 0.0001 and targetValue < firingRange and gun:acfReady() and (relativeAccel != -Vector(0, 0, GRAVITY[2]) or targetValue < 1000)  do
        time = (low + high) / 2
        
        -- Predict target position with acceleration applied
        predictedTargetPos = relativePos + relativeVel * time + 1/2 * relativeAccel * time^2
        targetValue = predictedTargetPos:getLength() - muzzleDist
        data = ballisticslib.logic(gun, predictedTargetPos, time)
        selfValue = data[1]:getLength()
        
        if targetValue > maxCalculatedRange then
            break  
        end
        
        -- Make sure we stop if we go past the target or if the target goes past us
        if targetValue > selfValue and predictedTargetPos:dot(relativePos) > 0 then
            low = time
        else
            high = time
        end           
    end
    
    --print(data[1]:getLength() .. " .. " .. data[2] .. " .. " .. time)
    
    -- Wire outputs
    local timeOutput = time
    local aimposOutput = targetPos + relativeVel * (timeOutput + offset) + 0.5 * relativeAccel * (timeOutput + offset)^2
    wire.ports.Time = timeOutput
    wire.ports.AimPos = aimposOutput
    
    -- Gun fire handling
    if handleFiring and targetValue < firingRange and gun:acfReady() and time != low then
        -- Barrel alignment check
        local muzzle = gun:getAttachment(gun:lookupAttachment("muzzle"))
        local muzzleVec = Vector(muzzle[1], muzzle[2], muzzle[3])
        local gunFwd = gun:getForward()
        local toAim = aimposOutput - muzzleVec
        local proj = gunFwd * toAim:dot(gunFwd)
        local closest = muzzleVec + proj
        local error = (aimposOutput - closest):getLength()

        if error < firingAccuracy then
            gun:acfFire(1)
        end
    end
    
    -- Acceleration resetting
    timer.create("Reset Acceleration", 0.3, 1, function() lastVel = Vector() end)
end

--- Updates variables with their respective values when needed
-- Also attempts logic when possible
local function handleWire(name, value)
    if name == "Gun" then
        gun = value
    elseif name == "TargetPos" then
        targetPos = value    
    elseif name == "TargetVel" then
        targetVel = value    
    end
end

--- Need to retry in-case the ballistics change, just in case
-- Try to update the logic every 1s
timer.create("retry", 0.1, 0, function()
    if gun:isValid() and gun:acfMuzzleVel() == 0 then
        gun:acfFire(1)
    elseif gun:isValid() then
        if gun:acfMuzzleVel() != storedMuzzleVel then
            storedMuzzleVel = gun:acfMuzzleVel()
            maxCalculatedRange = ballisticslib.calculate_maximum_distance(gun)
            local attachmentInfo = gun:getAttachment(gun:lookupAttachment("muzzle"))
            local muzzlePos = Vector(attachmentInfo[1], attachmentInfo[2], attachmentInfo[3])
            muzzleDist = gun:localToWorld(Vector()):getDistance(muzzlePos)
        end
        gun:acfFire(0)
    end
end)

--- Hook for when the wire inputs are updated
-- This is basically the only hook we need since we only care when we are actually recieving data
wire.adjustPorts({Gun = "entity", TargetPos = "vector", TargetVel = "vector"},{Time = "number", AimPos = "vector"})
hook.add("input", "Wire Inputs Updated", handleWire)

--- Main think hook, pretty self explanatory
hook.add("think", "Main Think", main)
