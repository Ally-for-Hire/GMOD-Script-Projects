--@name ACF Ballistics Livesim Calculator
--@author Ally for Hire / Merydian9
--@server

-- Constants go here
local GRAVITY = physenv.getGravity()
local TIMESTEP = game.getTickInterval()
local UNITS = 39.37
local MAXTIME = 999999
local DRAGDIV = 40

-- Functions go here

-- This will return a table of the shell's positions starting at the guns base
-- taking angle as the pitch, the following function will visualize any given
-- position accurately: gun:localToWorld(Vector(bullet_pos[1], 0, bullet_pos[2]))
local function generate_ballistics (gun, angle, simplicity) -- Entity, Number, Number
    -- gun is the gun
    -- angle is the starting pitch
    -- simplicity is how much less complex it is, 1 is default simplicity
    
    -- Initializing the bullet variables
    local bullet_accel = Vector2(0, GRAVITY[3])
    local bullet_timestep = TIMESTEP * simplicity
    local bullet_flighttime = 0
    local bullet_muzzlevel = gun:acfMuzzleVel() * UNITS
    local bullet_dragcoef = gun:acfDragCoef() * UNITS
    local bullet_table = {}
    
    -- Doing proper conversion of the angle into vector
    local angle_muls = Vector2(math.cos(math.rad(angle)), math.sin(math.rad(angle)))
    
    -- Calculating the starting position and velocity
    local muzzle_attachment = gun:getAttachment(gun:lookupAttachment("muzzle"))
    local muzzle_pos = Vector(muzzle_attachment[1], muzzle_attachment[2], muzzle_attachment[3])
    local muzzle_dist = gun:getMassCenterW():getDistance(muzzle_pos)
    
    local bullet_pos = angle_muls * muzzle_dist
    local bullet_vel = angle_muls * bullet_muzzlevel
    
    -- The actual bullet generation logic
    while bullet_flighttime < MAXTIME and bullet_pos[1] < 40000 and bullet_vel[1] > 600 do -- You never really need to go farther than 40000 units
        local drag = (bullet_dragcoef * bullet_vel:getLength()^2) / DRAGDIV
        local clampedflight = bullet_vel:getLength() * 0.9
        drag = bullet_vel:getNormalized() * math.min(drag * bullet_timestep, clampedflight)
        
        bullet_pos = bullet_pos + (bullet_vel * bullet_timestep)
        bullet_vel = bullet_vel + (bullet_accel * bullet_timestep - drag)
        table.insert(bullet_table, {bullet_pos, bullet_vel, bullet_flighttime})

        bullet_flighttime = bullet_flighttime + bullet_timestep 
    end
    
    -- Returning the given values
    return bullet_table
end

-- This will return the final data before the bullet passes a threshold on the x axis
local function generate_ballistics_capped (gun, angle, cap, simplicity) -- Entity, Number, Number, Number
    -- gun is the gun
    -- angle is the starting pitch
    -- cap is the maximum x value
    -- simplicity is how much less complex it is, 1 is default simplicity
    
    -- Initializing the bullet variables
    local bullet_accel = Vector2(0, GRAVITY[3])
    local bullet_timestep = TIMESTEP * simplicity
    local bullet_flighttime = 0
    local bullet_muzzlevel = gun:acfMuzzleVel() * UNITS
    local bullet_dragcoef = gun:acfDragCoef() * UNITS

    -- Doing proper conversion of the angle into vector
    local angle_muls = Vector2(math.cos(math.rad(angle)), math.sin(math.rad(angle)))
    
    -- Calculating the starting position and velocity
    local muzzle_attachment = gun:getAttachment(gun:lookupAttachment("muzzle"))
    local muzzle_pos = Vector(muzzle_attachment[1], muzzle_attachment[2], muzzle_attachment[3])
    local muzzle_dist = gun:getMassCenterW():getDistance(muzzle_pos)
    
    local bullet_pos = angle_muls * muzzle_dist
    local bullet_vel = angle_muls * bullet_muzzlevel
    
    -- The actual bullet generation logic
    while bullet_flighttime < MAXTIME and bullet_pos[1] < 40000 and bullet_pos[1] < cap and bullet_vel[1] > 600 do -- You never really need to go farther than 40000 units
        local drag = (bullet_dragcoef * bullet_vel:getLength()^2) / DRAGDIV
        local clampedflight = bullet_vel:getLength() * 0.9
        drag = bullet_vel:getNormalized() * math.min(drag * bullet_timestep, clampedflight)
        
        bullet_pos = bullet_pos + (bullet_vel * bullet_timestep)
        bullet_vel = bullet_vel + (bullet_accel * bullet_timestep - drag)
        
        bullet_flighttime = bullet_flighttime + bullet_timestep 
    end
    
    -- Returning the final value
    return bullet_pos
end

-- Logic goes here
wire.adjustPorts({Gun = "entity", Position = "vector", Run = "number"},{Pitch = "number"})

local function logic (input_name, input_value) -- String, Any
    if input_name != "Run" or input_value != 1 then return end
    if not isValid(wire.ports.Gun) then return end
    
    local gun = wire.ports.Gun
    local position = wire.ports.Position
    
    local distance = gun:getPos():getDistance(position)
    local max_shot = generate_ballistics(gun, 45, 1)
    local maximum_distance
    
    for i = 1, #max_shot do
        if max_shot[i][1][2] < 0 then
            maximum_distance = max_shot[i][1][1]
            break
        end        
    end

    if distance > maximum_distance then 
        print("No Solution") 
        return 
    end

    local low = -90
    local high = 90
    local mid = (low + high) / 2
    local comparison = position[3] - gun:getPos()[3]
    
    while (high - low) > 1 do
        mid = (low + high) / 2
        local test = generate_ballistics_capped(gun, mid, distance, 8)    

        if test[2] > comparison then
            high = mid    
        else
            low = mid
        end
    end
    while (high - low) > 0.01 do
        mid = (low + high) / 2
        local test = generate_ballistics_capped(gun, mid, distance, 1)    

        if test[2] > comparison then
            high = mid    
        else
            low = mid
        end
    end
    
    wire.ports.Pitch = mid
    print("Ballistics Angle: " .. mid)
end

-- Hooks go here
hook.add("input", "Update Inputs", logic)
